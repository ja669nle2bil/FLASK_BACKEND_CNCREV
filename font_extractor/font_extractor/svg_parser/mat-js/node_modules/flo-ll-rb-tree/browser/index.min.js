var t={d:(o,r)=>{for(var e in r)t.o(r,e)&&!t.o(o,e)&&Object.defineProperty(o,e,{enumerable:!0,get:r[e]})},o:(t,o)=>Object.prototype.hasOwnProperty.call(t,o)},o={};t.d(o,{E5:()=>n,RL:()=>r,dn:()=>a,NB:()=>u,hM:()=>i,pX:()=>e,xC:()=>s,iK:()=>m,Wl:()=>h,Qx:()=>p});const r=-1,e=1,n=1,i=0;class u{constructor(t){this.datum=t,this.color=i}}function s(t){return!!t&&t.color===i}class a{constructor(t,o=!0,n){if(this.compare=t,this.duplicatesAllowed=o,this.getMinNode=this.getMinOrMaxNode(r),this.getMaxNode=this.getMinOrMaxNode(e),this.root=void 0,this.nodeCount=0,this.valueCount=0,n)for(const t of n)this.insert(t)}isEmpty(){return!this.root}find(t){const o=this;let n=this.root;for(;n;){const i=o.compare(t,n.datum);if(0===i)return n;n=n[i>0?e:r]}}toArrayInOrder(){const t=[];return function o(n){n&&(o(n[r]),t.push(n.datum),void 0!==n.extras&&t.push(...n.extras),o(n[e]))}(this.root),t}insertMulti(t){const o=this;for(const r of t)o.insert(r)}insert(t){const o=this;o.root=function t(n,i){if(void 0===n)return o.valueCount++,o.nodeCount++,new u(i);const a=o.compare(i,n.datum);if(0===a&&(o.duplicatesAllowed?(o.valueCount++,void 0===n.extras?n.extras=[i]:n.extras.push(i)):n.datum=i),0!==a){const o=a>0?e:r;n[o]=t(n[o],i),n[o].parent=n}return s(n[e])&&!s(n[r])&&(n=d(r,n)),s(n[r])&&s(n[r][r])&&(n=d(e,n)),s(n[r])&&s(n[e])&&c(n),n}(o.root,t),o.root.color=n,o.root.parent=void 0}remove(t,o=!1,i){const u=this;if(void 0===u.root)return;let a;const m=function t(n,m){const h=u.duplicatesAllowed&&void 0!==n.extras;let p=u.compare(m,n.datum);if(p<0&&!n[r]||p>0&&!n[e])return n;if(p<0){s(n[r])||s(n[r][r])||(n=f(n));const o=t(n[r],m);return null===o?null:(n[r]=o,n[r]&&(n[r].parent=n),v(n))}if(s(n[r])&&(n=d(e,n),p=u.compare(m,n.datum)),0===p&&!n[e]){if(h&&!o){if(void 0===i||!0===i(m,n.datum))return a=n.datum,n.datum=n.extras.pop(),u.valueCount--,0===n.extras.length&&(n.extras=void 0),n;{const t=n.extras;for(let o=0;o<t.length;o++)if(!0===i(m,t[o]))return a=t.splice(o,1)[0],u.valueCount--,0===t.length&&(n.extras=void 0),n;return null}}return void 0===i||!0===i(m,n.datum)?(a=n.datum,u.valueCount-=1+(h?n.extras.length:0),void u.nodeCount--):null}if(s(n[e])||s(n[e][r])||(n=function(t){return c(t),s(t[r][r])&&c(t=d(e,t)),t}(n),p=u.compare(m,n.datum)),0===p)if(h&&!o)if(void 0===i||!0===i(m,n.datum))a=n.datum,n.datum=n.extras.pop(),u.valueCount--,0===n.extras.length&&(n.extras=void 0);else{const t=n.extras;let o=!1;for(let r=0;r<t.length;r++)if(!0===i(m,t[r])){a=t.splice(r,1)[0],u.valueCount--,0===t.length&&(n.extras=void 0),o=!0;break}if(!o)return null}else{if(void 0!==i&&!0!==i(m,n.datum))return null;{u.valueCount-=1+(h?n.extras.length:0),a=n.datum;const t=u.getMinNode(n[e]);n.datum=t?.datum,u.duplicatesAllowed&&(n.extras=t?.extras),n[e]=l(n[e]),u.nodeCount--}}else{const o=t(n[e],m);if(null===o)return null;n[e]=o}return n[e]&&(n[e].parent=n),v(n)}(u.root,t);return null!==m?(u.root=m,void 0!==u.root&&(u.root.color=n,u.root.parent=void 0),a):void 0}findBounds(t){const o=this;let n=o.root;const i=[void 0,void 0];if(void 0===n)return i;for(;n;){const u=o.compare(t,n.datum);u>=0?i[0]=n:i[1]=n,n=n[u>=0?e:r]}return i}findBoundsExcl(t){const o=this,n=o.root,i=[void 0,void 0];return void 0===n||function n(u){for(;u;){const s=o.compare(t,u.datum);if(0===s)return n(u[r]),void n(u[e]);s>0?i[0]=u:s<0&&(i[1]=u),u=u[s>0?e:r]}}(n),i}findAll(t){const o=this;let n=this.root;for(;n;){const i=o.compare(t,n.datum);if(0===i)return[n.datum,...n.extras?n.extras:[]];n=n[i>0?e:r]}return[]}getMinOrMaxNode(t){return o=>{if(void 0===o&&(o=this.root),o){for(;o[t];)o=o[t];return o}}}min(t){void 0===t&&(t=this.root);const o=this.getMinNode(t);if(void 0!==o)return o.datum}max(t){void 0===t&&(t=this.root);const o=this.getMaxNode(t);if(void 0!==o)return o.datum}}function d(t,o){const r=o[-t];return o[-t]=r[t],r[t]&&(r[t].parent=o),r[t]=o,o.parent=r,r.color=o.color,o.color=i,r}function l(t){if(t[r])return s(t[r])||s(t[r][r])||(t=f(t)),t[r]=l(t[r]),t[r]&&(t[r].parent=t),v(t)}function c(t){t.color=(t.color+1)%2,t[r].color=(t[r].color+1)%2,t[e].color=(t[e].color+1)%2}function f(t){if(c(t),s(t[e][r])){const o=d(e,t[e]);t[e]=o,o.parent=t,c(t=d(r,t))}return t}function v(t){return s(t[e])&&(t=d(r,t)),s(t[r])&&s(t[r][r])&&(t=d(e,t)),s(t[r])&&s(t[e])&&c(t),t}function m(t){return o=>{let r;return r=void 0!==o.extras?`{${[o.datum,...o.extras].map(t)}}`:t(o.datum),r+(s(o)?"•":"·")}}const h=m((t=>t.toString()));function p(t){return o=>{const n=o.root;let i="";return function o(n){void 0!==n&&(i+=t(n),(void 0!==n[r]||null!=n[e])&&(void 0!==n[r]&&(i+="(",o(n[r]),i+=")"),void 0!==n[e]&&(i+="[",o(n[e]),i+="]")))}(n),i}}var x=o.E5,g=o.RL,C=o.dn,M=o.NB,N=o.hM,A=o.pX,O=o.xC,b=o.iK,w=o.Wl,E=o.Qx;export{x as BLACK,g as LEFT,C as LlRbTree,M as Node,N as RED,A as RIGHT,O as isRed,b as nodeToStr,w as numberNodeToStr,E as treeToStr};